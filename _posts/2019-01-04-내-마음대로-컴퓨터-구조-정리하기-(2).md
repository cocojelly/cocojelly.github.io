---
title:  "내 마음대로 컴퓨터 구조 정리하기 (2)"
date:   2019-01-04 23:36:00
categories: computer
tags: computer architecture
---

<br>

주제 - **"컴퓨터 구조(2)"**  

부제 - 컴퓨터 부팅 과정, 프로그램의 동작 원리 살펴보기

참고 서적 

- [`Computer Organization and Design The Hardware/Software Interface Fifth Edition, Asian Edition - David A. Patterson, John L. Hennessy`](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788964212134&orderClick=LAG&Kc=)  
- [`운영체제 -  Silberschatz , Peter B. Galvin, Greg Gagne`](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788998886813&orderClick=LAG&Kc=)

<br><br><br>

---

## 2. 동작 원리를 살펴보기

---

이번에는 응용 소프트웨어, 시스템 소프트웨어, 하드웨어를 아울러서 **컴퓨터가 켜지고, 프로그램이 실행되는 과정**을 정리해보겠습니다.

<br><br>

### 2-1. 컴퓨터가 켜지는 과정

<br>

CPU는 컴퓨터에 전원이 들어오면 제일 먼저 메모리의 0번지 주소의 데이터를 읽습니다.  메모리 0번지에는 **ROM**(Read-Only Memory)이라는, **컴퓨터를 구동하기 위한 기본 정보가 담긴 메모리**가 있습니다. ROM은 컴퓨터의 전원을 꺼도 메모리가 지워지지 않아, 컴퓨터가 켜지면 이 곳의 정보를 읽어올 수 있습니다.  

따라서 전원이 켜지면 ROM에서 읽어들인 내용을 바탕으로 **하드웨어의 상태를 확인하는 POST**(Power On Self Test)를 수행합니다. 그리고 **운영체제를 로드**하기 위해 디스크의 첫번째 섹터인 마스터 부트 레코드(Master Boot Record, MBR)를 읽습니다. 이 MBR에서 부트 코드(Boot Code)가 실행됩니다. 부트 코드는 부팅 가능한 파티션을 찾아 해당 파티션의 부트 레코드(Boot Record)를 호출하고, 해당 파티션 부트 레코드는 RAM에 적재됩니다.  

위의 과정이 모두 끝나면, 부팅이 시작됩니다.  

<br>

![image](https://user-images.githubusercontent.com/23413819/50676565-5c0bc900-1038-11e9-8701-22a577f6a364.png)

<br>

위의 그림과 함께 컴퓨터의 부팅과정을 순서대로 정리하면 아래와 같습니다.  

1. 컴퓨터에 전원이 들어오면 POST 과정 수행
2. 운영체제 로드를 위한 과정 시작
3. MBR 읽기
4. MBR의 부트 코드가 실행, 이는 부팅 가능한 파티션을 찾는 역할
5. 파티션 테이블에서 부팅 가능한 파티션을 찾음 (그림에서는 Partition1)
6. 해당 파티션의 첫번째 섹터인 파티션 부트 레코드를 메모리에 적재하여 실행
7. 해당 파티션으로 부팅이 시작됨

<br><br>

### 2-2. 프로그램이 실행되는 과정

<br>

하나의 프로그램은 프로그램이 수행할 다양한 동작을 담은 코드, 즉 **명령어**들로 이루어져 있습니다. 아래에서는 Partition1로 부팅된 컴퓨터로 사용자가 Program0을 실행시키는 경우를 예로 하여, 프로그램이 실행되는 과정을 보겠습니다.  

아래는 CPU, 메모리, 디스크를 전체적으로 나타낸 이미지로, 프로그램이 실행되는 과정을 상세히 살펴보기 위해 CPU 내부를 좀 더 자세히 표현하였습니다.

![image](https://user-images.githubusercontent.com/23413819/50689601-afe4d500-106d-11e9-8ccc-3ee19d166ac9.png)

>

[CPU 내부의 구성요소]

PC (Program Counter) : 다음에 실행할 명령의 메모리 주소를 가리키는 레지스터

- CPU에 따라 PC를 IP(Instruction Pointer)로 칭하기도 함

- 레지스터 : CPU 내에서 데이터를 저장할 수 있는 아주 빠른 기억 장치  

​		 주로 계산 중인 값을 저장하는데 사용

ALU (Arithmetic / Logic Unit) : 레지스터에 저장된 값을 가지고 산술 · 논리 연산을 수행

AC (Accumulator) : 산술 연산을 위한 레지스터 

MAR (Memory Address Register) : address bus로 향하는, 주소를 저장하는 레지스터

Control Unit : 명령이 뜻하는 바에 따라 다른 구성요소들이 할 일을 지시

IR (Instruction Register) : 현재 처리중인 명령을 저장

MBR (Memory Buffer Register) : data bus와 연결된, MAR에 저장된 주소에 있는 데이터를저장하는 레지스터

이 외의 레지스터들 : AX, BX, CX, DX, BP, SP, SI, DI, CS, SS, DS, ES, FS, GS, ZF, OF, CF 등

<br>[System Bus] : 컴퓨터 내의 다양한 요소들 간의 데이터 전송이 이루어지는 길

Address Bus : 주소 전송, CPU → RAM 단방향

Data Bus : 데이터 전송, CPU ↔ RAM 양방향

Control Bus : 제어 신호 전송, CPU → RAM 단방향

>

<br>

사용자에 의해 프로그램이 실행되면, 프로그램을 구성하는 명령어와 데이터가 운영체제에 의해 메모리에 적재됩니다. 이렇게 프로그램이 메모리에 적재되어 실행 중인 상태를 **프로세스**라고 합니다.  

![image](https://user-images.githubusercontent.com/23413819/50689613-bb380080-106d-11e9-87e7-85dd7ef85f16.png)

<br>프로그램이 메모리에 적재되면, 해당 프로세스의 주소값이 낮은 곳부터 메모리를 읽어 그 곳에 있는 명령을 수행합니다. 명령을 수행하는 과정은 크게 fetch와 execution으로 구성됩니다.  

`<fetch>`

1. 수행할 명령을 가지고 옴 (fetch instruction)
2. 명령을 해석 (decode instruction)

`<execution>`

3. 명령에 필요한 데이터를 가지고 옴 (get data)
4. 명령을 실행 (execute the instruction)

<br>

명령의 예시와 이미지를 통해 위의 과정을 살펴보겠습니다.

![image](https://user-images.githubusercontent.com/23413819/50692177-5c2ab980-1076-11e9-8a41-a12bd0522560.png)

0x3333 주소의 명령1은 <u>주소값이 100인 곳에 들어있는 데이터를 AC 레지스터에 적재하라</u>는 의미라고 하겠습니다.  

적재된 프로세스가 실행될 때, PC는 해당 프로세스에서 제일 처음 실행해야하는 명령어의 주소를 가리킵니다. 위의 예시에서는 제일 처음 실행해야 하는 명령이 명령1 이니, PC에 담긴 주소는 0x3333이 될 것입니다.  

<br>

명령1이 실행되면, 위에서 언급했던 fetch - execution 과정이 수행됩니다.

`<fetch>`

1. PC가 가진 주소값 0x3333을 MAR로 전달
2. PC는 다음 명령의 주소값을 가리킴, MAR에 담긴 값 0x3333은 address bus를 통해 전달되어 프로세스 메모리 상의 주소 0x3333의 명령을 읽음
3. 주소 0x3333에 있던 명령 LOAD 100은 control bus를 통해 MBR로 전달
4. MBR로 전달된 명령은 IR에 적재됨

![image](https://user-images.githubusercontent.com/23413819/50692196-6e0c5c80-1076-11e9-8258-6c294d6b9475.png)

`<execution>`

5. IR에 담긴 명령에서 필요한 데이터가 주소값 100에 존재하는 데이터이므로, 주소값 100을 MAR로 전달
6. MAR에 담긴 값 100은 address bus를 통해 전달되어, 프로세스 메모리 상의 주소 100에 들어있는 값을 읽음
7. 주소 100에 있던 값 24는 control bus를 통해 MBR로 전달
8. MBR로 전달된 값은 AC에 적재됨 

![image](https://user-images.githubusercontent.com/23413819/50692205-79f81e80-1076-11e9-86ca-162c26097370.png)

<br>

명령 1의 수행이 끝나면, 다음 fetch - execution의 과정이 이어집니다. 이 때 PC에 든 값은 그 다음 명령인 명령2를 가리키고 있으니, 결국 프로세스의 명령이 그 순서대로 수행이 되어 프로그램이 전체적으로 동작하는 것입니다.

<br><br>

정리를 원하는 내용을 적다보니, 타이틀과는 어울리지 않는 내용이 이어지게 될 것 같아 컴퓨터 구조 정리하기는 여기까지로 마무리합니다. 나중에 정리하고 싶은 것이 생긴다면 또 이어질지도 모르겠습니다:grin: 

<br><br><br>

------

### 레지스터에 대한 이야기  

------

위의 글 내용에서 이 외의 레지스터들로만 언급이 되고 넘겼던 레지스터들에 대해 정리를 해보고자 합니다.   <br>

1. 범용 레지스터 : 다양한 용도로 사용되지만 주로 CPU가 사용할 임시 변수를 저장하는 역할 수행

   - AX (Accumulator) : 산술 연산 수행과 연산 결과 저장에 사용됨
   - BX (Base) : 데이터에 대한 포인터로 사용됨 
   - CX (Counter) : 반복문이나 문자열의 카운터로 사용됨 
   - DX (Data) : 데이터 저장용으로 사용됨

   - SP (Stack Pointer) : 스택의 Top, 가장 최근에 스택에 쌓인 데이터의 위치를 가리킴
   - BP (Base Pointer) : 현재 실행 중인 스택 프레임의 시작 주소를 가리킴
   - SI (Source Index) : 데이터 연산을 위한 소스 인덱스 또는 입력 데이터 스트림의 위치를 가리킴 
   - DI (Destination Index) : 데이터 연산의 결과가 저장되는 위치를 가리킴

2. 세그먼트 레지스터 : 프로세스의 메모리 영역을 구분하는 역할

   - CS (Code Segment) : 코드 영역의 시작 주소를 담고 있음
   - DS (Data Segment) : 데이터 영역의 시작 주소를 담고 있음
   - SS (Stack Segment) : 스택 영역의 시작 주소를 담고 있음

3. 기타 레지스터

   - EFLAGS : status, control, system 플래그들을 담고 있는 레지스터
     - Status flag : carry, parity, zero, sign, overflow flag등
     - Control flag : direction flag
     - System flag : interrupt, trap flag 등
   - IP (instruction pointer) : 다음에 실행될 명령의 위치를 가리키는 레지스터
     - CPU에 따라 PC (Program Counter) 라고 칭하기도 함

<br>

위에서 언급한 각 레지스터 중, 범용 레지스터는 PC의 역사적 변화에 따라 그 명칭이 바뀌었습니다. 제가 위에서 정리한 형태는 16bit 시절에 불렸던 형태이며, 현재는 32bit로의 확장에 따라 앞에 **E**가 붙은 EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI, EIP 의 형태가 사용됩니다.  

각 범용 레지스터와 EFLAGS, EIP는 32bit 이며, 세그먼트 레지스터는 16bit입니다. 그리고 범용 레지스터는 그 일부만을 칭할 때 다른 명칭이 붙기도 하는데, 그는 아래의 이미지와 같습니다.

![image](https://user-images.githubusercontent.com/23413819/50736921-772c3380-1206-11e9-924c-43387e1d7644.png)

예를 들어, EAX의 하위 8비트를 AL 이라고 표현하는 것입니다. 이러한 표현은 어셈블리어에서 자주 등장하므로, 알아두면 좋습니다.

<br>

여기까지 레지스터들에 대한 간략한 정리를 마치겠습니다.

<br><br><br>

------

### 메모리에 대한 이야기  

------

컴퓨터를 구성하는 메모리는 CPU 내부에 존재하는 **레지스터**, 주 메모리인 **RAM**, 비휘발성으로 저장해야하는 데이터를 담고 있는 **디스크**가 있습니다. 이들은 모두 서로 다른 **처리 속도와 용량**을 가지고 있습니다.  

일반적으로, CPU에 가까이 위치하는 메모리일수록 속도가 빠르고 용량이 작으며 가격이 비싸집니다. 그렇기에 RAM의 처리 속도가 CPU에 미치지 못해 명령 수행에 지연이 발생합니다. 그래서 그 둘간의 속도 차이 완화를 위한 캐시가 CPU에 부착되고, 아래의 이미지와 같은 메모리 계층 구조가 구성되게 됩니다.

![image](https://user-images.githubusercontent.com/23413819/50723085-3821b380-111c-11e9-8141-9397cf3ed705.png)

<br>

이번 글에서 주로 다루었던 명령의 실행과정을 보면, 레지스터와 RAM 사이에는 수많은 데이터의 이동이 발생합니다. 이런 데이터의 이동은 **CPU가 명령의 처리를 위해 필요한 데이터를 요청하는 경우**에 발생하곤 합니다. 이런 데이터 처리를 다룰 때 사용하는 용어가 있는데, **적중(hit)**과 **실패(miss)**입니다.  

- 적중 (hit) : 프로세서가 요구한 데이터가 상위 계층(CPU에 가까운 메모리 계층)에 존재할 때
- 실패 (miss) : 프로세서가 요구한 데이터를 상위 계층에서 찾을 수 없을 때

CPU가 요청한 데이터가 레지스터라는 최상위 계층에 존재한다면, 데이터를 요청해서 받아오는 과정은 빠르게 처리될 것입니다. 하지만 존재하지 않는다면, 하위 계층의 메모리로 접근하여 필요한 데이터를 찾아나서야 합니다. 

- 적중률 (hit rate / hit ratio) : 메모리 계층의 성능을 평가하는 척도, 데이터를 찾기 위해 특정 메모리에 접근 했을 때 해당 계층에서 찾을 수 있는 것의 비율
- 실패율 (miss rate, 1 - 적중률) : 데이터를 찾기 위해 특정 메모리에 접근 했을 때 해당 계층에서 찾을 수 없는 것의 비율
- 적중 시간 (hit time) : 특정 메모리 계층에 접근하여 적중 / 실패 여부를 결정하는데까지 필요한 시간
- 실패 손실 (miss penalty) : 하위 계층에서 필요한 데이터를 가져와서, 상위 계층에 전달되는 시간 + 데이터가 CPU에 전달되기까지의 시간

위 용어의 정의를 보면 알 수 있듯이, CPU에 가까운 메모리일수록 적중 시간과 실패 손실이 적습니다. 

<br>

빠른 시간 내에 명령을 처리하기 위해서는, CPU가 필요로 하는 데이터가 빠르게 전달되는 것이 좋습니다. 즉, 필요로 할 것 같은 데이터들이 상위 계층에 있을 수록 빠른 처리가 이루어질 것입니다. 그렇다면 어떻게 필요로 할 것 같은 데이터들을 뽑아낼 수 있을까요?  

이는 **지역성의 원리**와 밀접한 관련이 있습니다. 

- 지역성의 원리 (principle of locality) : 프로그램은 비교적 최근에 접근한, 비교적 이전과 가까운 주소 공간의 메모리에 접근할 가능성이 높음
- 시간적 지역성 (temporal locality) : 어떤 항목이 참조되면, 그 데이터는 빠른 시간 내에 다시 참조될 가능성이 높음
- 공간적 지역성 (spatial locality) : 어떤 항목이 참조되면, 그 데이터의 근처에 위치한 데이터들이 참조될 가능성이 높음

많은 프로그램은 반복문 구조를 가지고 있고, 이는 명령과 데이터에 반복적으로 접근하기에 상당한 **시간적 지역성**을 보입니다. 또한, 명령들은 순차적으로 접근되는 경우가 많기에 **공간적 지역성**을 보이기도 합니다. 그리고 메모리 계층구조는 이러한 특성들을 활용하여 필요한 데이터들을 상위 계층에 적재합니다.  

위와 같은 특징들과 함께 메모리의 계층구조와 성능 등에 대한 정리를 해보았습니다.

<br><br><br>

---

이전 - [내 마음대로 컴퓨터 구조 정리하기 (1)](https://cocojelly.github.io/computer/%EB%82%B4-%EB%A7%88%EC%9D%8C%EB%8C%80%EB%A1%9C-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-(1)/)  
